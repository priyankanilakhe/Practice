package LinkedList;

import LinkedList.LinkedList.Node;

public class SumOfNodeByAddingOne {
	
	 public void push(int new_data)
	    {
	        /* 1 & 2: Allocate the Node &
	                  Put in the data*/
	        Node new_node = new Node(new_data);
	 
	        /* 3. Make next of new Node as head */
	        new_node.next = head;
	 
	        /* 4. Move the head to point to new Node */
	        head = new_node;
	    }
	   Node head; // head of linked list
	   
	    /* Linked list node */
	    class Node
	    {
	        int val;
	        Node next;
	        Node(int d)
	        {
	            val = d;
	            next = null;
	        }
	    }
	    public void printList()
	    {
	        Node tnode = head;
	        while (tnode != null)
	        {
	            System.out.print(tnode.val+"->");
	            tnode = tnode.next;
	        }
	        System.out.println("NULL");
	    }
	    
	    static Node reverse(Node head)
	    {
	        Node prev = null;
	        Node current = head;
	        Node next = null;
	        while (current != null) {
	            next = current.next;
	            current.next = prev;
	            prev = current;
	            current = next;
	        }
	        return prev;
	    }
	    static Node newNode(int data)
	    {
	        Node new_node = new Node();
	        new_node.data = data;
	        new_node.next = null;
	        return new_node;
	    }
	    /* Adds one to a linked lists and return the head
	    node of resultant list */
	    static Node addOneUtil(Node head)
	    {
	        // res is head node of the resultant list
	        Node res = head;
	        Node temp = null, prev = null;
	  
	        int carry = 1, sum;
	  
	        while (head != null) // while both lists exist
	        {
	            // Calculate value of next digit in resultant
	            // list. The next digit is sum of following
	            // things (i) Carry (ii) Next digit of head list
	            // (if there is a next digit)
	            sum = carry + head.val;
	  
	            // update carry for next calculation
	            carry = (sum >= 10) ? 1 : 0;
	  
	            // update sum if it is greater than 10
	            sum = sum % 10;
	  
	            // Create a new node with sum as data
	            head.val = sum;
	  
	            // Move head and second pointers to next nodes
	            temp = head;
	            head = head.next;
	        }
	  
	        // if some carry is still there, add a new node to
	        // result list.
	        if (carry > 0)
	            temp.next = new Node(carry);
	  
	        // return head of the resultant list
	        return res;
	    }
	  
	    // This function mainly uses addOneUtil().
	    static Node addOne(Node head)
	    {
	        // Reverse linked list
	        head = reverse(head);
	  
	        // Add one from left to right of reversed
	        // list
	        head = addOneUtil(head);
	  
	        // Reverse the modified list
	        return reverse(head);
	    }
	      	
	    
	public static void main(String[] args){
	
		int arr[]={1,2,3,4,5};
		SumOfNodeByAddingOne ll=new SumOfNodeByAddingOne();
		
		for(int i=0;i<arr.length;i++)
		{
			ll.push(arr[i]);
		}
		ll.printList();	
		//System.out.print(deleteNodeMiddle(ll.head).val);
		
	}
}

